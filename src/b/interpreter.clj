;;## Introduction
;; BLA is an animator for the B language written in the Lisp dialect
;; [Clojure](http://clojure.org/ "Clojure").
;; # Translation approach
;; We use some kind of compilation approach to calculate expressions and
;; predicates. The AST generated by the B parser is turned into a
;; Clojure datastructure, e.g., #EXPRESSION 4+2 will result in the
;; datastructure
;;      (AAddExpression
;;        (AIntegerExpression "4")
;;        (AIntegerExpression "1"))
;; which can be evaluated. Result of this evaluation is a function
;; that takes an environment of variable bindings and produces the
;; value of the expression (or truth value of the predicate) together
;; with a new environment (which can be different from the input if we
;; evaluate substitutions).

(ns b.interpreter
  (:gen-class)	
  (:require [b.reader :as reader])
  (:require [b.typecheck :as type])
  (:require [b.sets :as set])
  (:use clojure.algo.monads))

;;# Using the state monad
;;We use the maybe-monad-transformer on the state monad. The result is
;;used in the animator. We cannot use the state monad itself because
;;we need to deal with undefined results (e.g., if we divide by zero.)
(def wd-state-m (maybe-t state-m))

;; To create monadic versions of regular functions we use m-lift. In the same step,
;; we want to rename them to reflect the names of the syntax tree node
;; used in the parser. For example, lifting the integer addition is done 
;; by lifting the clojure + function, i.e., 
;; (lift AAddExpression + 2)
;; we will get 
;; (def AAddExpression (with-monad wd-state-m (m-lift 2 +))). 
;; Roughly speaking (+ a b) becomes something similar to (fn [env] [(+ (ma e) (mb e)) env]),
;; where ma and mb are the monadic versions of a and b. 
;; Punning on the name of the syntax tree will allow us to simply evaluate 
;; the syntax tree yielding a big function that takes an environment
;; as its input and calculates the value producing the required side effects. 

(defmacro lift
  ([name op n] `(def ~name (with-monad wd-state-m (m-lift ~n ~op))))
  ([name op n & more] `(do (lift ~name ~op ~n) (lift ~@more))))

(declare bmod bdiv bminus bmult powerset notmember bmin bmax brange)

;; Retrieving a variable from the state is handled by the fetch-val
;; function defined in the monads library.
(def AIdentifierExpression fetch-val)

;; Integer values are simply transformed into monadic values. An
;; integer value x therefore becomes a function (fn [env] [x env])
(def AIntegerExpression (with-monad wd-state-m m-result))

;; Direct set definitions, such as {1,2,3} cannot be simply lifted
;; because we have to recursivly turn the contained values into
;; monadic values. 
(defn ASetExtensionExpression [& x] (with-monad wd-state-m ((m-lift 1 (partial into #{})) (m-seq x))))

(defn ANatSetExpression [] (with-monad wd-state-m (m-result set/natural)))

;; # Lifting clojure functions
;; A big part of the interpreter can be produced using the lift
;; macro with matching clojure functions, such as +. In some cases, we
;; need to write the clojure functions to reflect the B semantics, for
;; instance, the * operator has two possible meanings (multiplication
;; and cartesian product) depening on the type of the arguments.

(lift
 AAddExpression                          +                               2
 AModuloExpression                       bmod                            2
 ADivExpression                          bdiv                            2
 AConjunctPredicate                      #(and % %2)                     2
 ADisjunctPredicate                      #(or % %2)                      2
 ANegationPredicate                      not                             1
 AEqualPredicate                         =                               2
 AUnaryMinusExpression                   (partial * -1)                  1
 AEmptySetExpression                     (constantly #{})                0
 AUnionExpression                        set/union                       2
 AIntersectionExpression                 set/intersection                2
 AMinusOrSetSubtractExpression           bminus                          2
 AMultOrCartExpression                   bmult                           2
 APowSubsetExpression                    powerset                        1
 ACardExpression                         count                           1
 ANotMemberPredicate                     notmember                       2
 AMinExpression                          bmin                            1
 AMaxExpression                          bmax                            1
 AIntervalExpression                     brange                          2
 ALessEqualPredicate                     <=                              2
 AGreaterEqualPredicate                  >=                              2
 ACoupleExpression                       vector                          2
 ABooleanTrueExpression                  (constantly true)               0
 ABooleanFalseExpression                 (constantly false)              0)                             

;; Several nodes in the AST should be ignored, because they are
;; irrelevant for evaluating an expression or predicate. For instance
;; the Start node of the syntax tree can be skipped. We actually
;; generate a macro for each syntax tree node that should be removed
;; and rewrite the Clojure datastructure.
(defmacro skip 
	([op] `(defmacro ~op [c#] c#))
	([op & more] `(do (skip ~op) (skip ~@more))))

;; Besides a couple of obvious AST nodes that can be skipped there is
;; AConvertBooleanExpression which is skipped because we pun on the
;; boolean type. In B the predicates are different from boolean
;; expressions. In our tool we do not distinguish between
;; them. This would allow us to use 1=1 as an expression 
;; without wrapping it in the B bool function, but the parser will
;; prevent us from doing so.

(skip alpha AExpressionParseUnit APredicateParseUnit Start AConvertBoolExpression)

;;# Rewritings
;;In some cases it is easier to rewrite a given AST node in terms of
;;other nodes. If we already have logical or and negation, we can
;;rewrite implication in terms of these junctors.
(defmacro AImplicationPredicate [x y] `(ADisjunctPredicate (ANegationPredicate ~x) ~y))   
(defmacro AEquivalencePredicate [x y] `(AConjunctPredicate (AImplicationPredicate ~x ~y) (AImplicationPredicate ~y ~x)))
(defmacro ANotEqualPredicate [x y] `(ANegationPredicate (AEqualPredicate ~x ~y)))
(defmacro APow1SubsetExpression [x] `(AMinusOrSetSubtractExpression (APowSubsetExpression ~x) (APowSubsetExpression (AEmptySetExpression))))
(defmacro AFinSubsetExpression [x] `(APowSubsetExpression ~x))
(defmacro AFin1SubsetExpression [x] `(APow1SubsetExpression ~x))
(defmacro AMemberPredicate [A B] `(ANegationPredicate (ANotMemberPredicate ~A ~B)))
(defmacro ALessPredicate [A B] `(ANegationPredicate (AGreaterEqualPredicate ~A ~B)))
(defmacro AGreaterPredicate [A B] `(ANegationPredicate (ALessEqualPredicate ~A ~B)))
(defmacro ASubsetPredicate [A B] `(AMemberPredicate ~A (APowSubsetExpression ~B)))
(defmacro ASubsetStrictPredicate [A B] `(AConjunctPredicate (ASubsetPredicate ~A ~B) (ANotEqualPredicate ~A ~B)))
(defmacro ANotSubsetPredicate [A B] `(ANegationPredicate (ASubsetPredicate ~A ~B)))
(defmacro ANotSubsetStrictPredicate [A B] `(ANegationPredicate (ASubsetStrictPredicate ~A ~B)))

;; ## The main functions

(defn tc [ast] [ast {}])
(defn evaluate [env [ast types]] ((eval ast) env))
(defn run [text, env]  (->> text reader/parse tc (evaluate env)))
(defn -main[ arg]
    (println (run arg {}))) 

;; ## The helper functions
;; In many cases we can simply lift an existing clojure function, but
;; sometimes we need to write functions to conform to the B semantics.

;; The B definition of modulo is rather strange. a mod b is only
;; defined if a is a non-negative number and b is a positive number.
(defn bmod [n m] 
	(if (or (< n 0) (<= m 0)) nil (rem n m)))

;; The divisor must not be zero.
(defn bdiv [n m]
	(if (= m 0) nil (int (/ n m))))
	
(defn bmin [S] (if (and (seq S) (every? number? S)) (apply min S) nil))

(defn bmax [S] (if (and (seq S) (every? number? S)) (apply max S) nil))	

;; The minus operator is overloaded. It can refer to arithmetic minus,
;; but also to set subtraction. Thus we need to dispatch on the types.
(defn bminus [a b]
	(cond (and (set? a) (set? b)) (set/difference a b)
	      (and (number? a) (number? b)) (- a b)
	      :else nil))		

;; For multiplication we have the same situation as for minus. It can
;; either refer to arithmetic multiplication or cartesian product. We
;; also dispach on the types of the arguments.
(defn bmult [a b]
	(cond (and (set? a) (set? b)) (into #{} (for [x a y b] [x y]))
	      (and (number? a) (number? b)) (* a b)
	      :else nil))		

(defn powerset [ls]
    (if (empty? ls) #{#{}}
        (set/union (powerset (next ls))
                    (into #{} (map #(conj % (first ls)) (powerset (next ls)))))))

	
(defn notmember [e S] (nil? (S e)))	
(defn member [e S] (not (notmember e S)))
(defn brange [m n] (into #{} (range m (inc n))))

